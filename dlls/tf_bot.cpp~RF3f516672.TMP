/***
*
*	Copyright (c) 1996-2001, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
/*

===== tf_bot.cpp ========================================================

  bot stuff :O
  this is a simple bot that only looks, walks towards enemies, and shoots. Not much else

  the logic from this bot is taken from my live tf2 bot
  you can get a link to the sourcemod plugin here:
  https://github.com/lovetaste-lovetaste/lovelybots
*/

#include <algorithm>
#include <string>
#include <vector>

#include "mathlib.h"
#include "extdll.h"
#include "util.h"
#include "filesystem_utils.h"
#include "cbase.h"
#include "com_model.h"
#include "saverestore.h"
#include "player.h"
#include "spectator.h"
#include "client.h"
#include "soundent.h"
#include "gamerules.h"
#include "game.h"
#include "customentity.h"
#include "weapons.h"
#include "weaponinfo.h"
#include "usercmd.h"
#include "netadr.h"
#include "pm_shared.h"
#include "pm_defs.h"
#include "UserMessages.h"
#include "tf_bot.h"
#include "teamplay_gamerules.h"

// CODE GRABBED FROM THE TF2SDK

static float g_LastBotUpdateTime[34];
// static CBaseEntity* enemy[40];
extern cvar_t bot_difficulty;

BotData g_BotData[TF_MAXPLAYERS];

inline bool isTempBot(int client)
{
	auto pPlayer = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	return (pPlayer && pPlayer->m_bIsConnected && (pPlayer->pev->flags & FL_FAKECLIENT) != 0);
}

inline float GetGameTime()
{
	return gpGlobals->time;
}

inline float angleCoordsToFaceCoords(Vector angles, Vector pos, Vector inputted_coords, bool absoluteAngle = false)
{
	Vector clientpos = pos;
	Vector targetpos = inputted_coords;
	Vector anglevector;
	Vector targetvector;
	float resultangle = 0.0f;

	if (absoluteAngle)
	{
		// Zero out pitch and roll, keep only yaw
		Vector lookAngles(0.0f, angles.y, 0.0f);

		// Get the forward vector from the yaw-only angle
		Vector forward, right, up;
		AngleVectors(lookAngles, &forward, &right, &up);
		VectorNormalize(forward);

		// Zero out Z so the comparison is done on the horizontal plane
		clientpos.z = 0.0f;
		targetpos.z = 0.0f;

		// Build a vector from the client to the target
		targetvector = targetpos - clientpos;
		VectorNormalize(targetvector);

		// Angle between the two vectors via dot product
		float dot = DotProduct(targetvector, forward);
		// Clamp to [-1, 1] to guard against floating-point drift
		dot = V_max(-1.0f, V_min(1.0f, dot));
		resultangle = acos(dot) * (180.0f / M_PI);
	}
	else
	{
		// Build vector from client to target and convert it to angles
		targetvector = targetpos - clientpos;
		VectorAngles(targetvector, anglevector);

		// Difference is only on the yaw axis
		resultangle = angles.y - anglevector.y;

		// Normalize into the [-180, 180] range
		if (resultangle < -180.0f)
		{
			resultangle = 360.0f + resultangle;
		}

		if (resultangle > 180.0f)
		{
			resultangle = 360.0f - resultangle;
		}
	}

	return resultangle;
}

inline void TF2_LookAtPos(int client, Vector* vecAngles, float flGoal[3], float flAimSpeed)
{
	auto player = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (!player)
	{
		return;
	}

	// Get the bot's world-space eye position (origin + view offset)
	Vector flEyePos = player->pev->origin + player->pev->view_ofs;

	// Get current view angles
	Vector flAng = player->pev->v_angle;

	// Compute direction vector from eye position to goal
	Vector desired_dir;
	desired_dir[0] = flGoal[0] - flEyePos[0];
	desired_dir[1] = flGoal[1] - flEyePos[1];
	desired_dir[2] = flGoal[2] - flEyePos[2];

	// Convert direction vector to pitch/yaw angles
	Vector desired_angles;
	desired_angles = UTIL_VecToAngles(desired_dir);

	// Ease current view angles toward the desired angles
	flAng[0] += AngleNormalize(desired_angles[0] - flAng[0]) * flAimSpeed;
	flAng[1] += AngleNormalize(desired_angles[1] - flAng[1]) * flAimSpeed;

	// Set the view angles (what the bot is actually "looking at")
	player->pev->v_angle = flAng;

	// Set model angles so the bot visually faces the target
	// Pitch is divided by 3 for GoldSrc model pitch convention
	player->pev->angles.x = flAng.x / 3.0f;
	player->pev->angles.y = flAng.y;
	player->pev->angles.z = 0;

	// Update ideal yaw and yaw speed for smooth model turning
	player->pev->ideal_yaw = flAng.y;
	player->pev->yaw_speed = 360.0f;
	player->ChangeYaw(player->pev->yaw_speed);

	// Optionally write out the resulting angles if vecAngles is provided
	if (vecAngles)
	{
		*vecAngles = flAng;
	}
}

//-----------------------------------------------------------------------------
// Purpose: Run this Bot's AI for one frame.
//-----------------------------------------------------------------------------
void Bot_Think(int client)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	// Make sure we stay being a bot
	if ((pBot->pev->flags & FL_FAKECLIENT) != 0)
		pBot->pev->flags |= FL_FAKECLIENT;

	float frametime = gpGlobals->time - g_LastBotUpdateTime[client];
	
	if (frametime > 0.25f || frametime < 0)
	{
		frametime = 0;
	}
	const byte msec = byte(frametime * 1000.0);

	Vector vecMove(0, 0, 0);
	byte impulse = 0;
	Vector vecViewAngles = pBot->pev->angles;
	pBot->pev->button = 0;

	if (pBot->GetTeamNumber() == TEAM_UNASSIGNED)
	{
		pBot->SetTeamNumber(TEAM_BLUE); //(RANDOM_LONG(0, 1) ? TEAM_RED : TEAM_BLUE));
	}
	else if (pBot->GetTeamNumber() != TEAM_UNASSIGNED && pBot->m_iClass == CLASS_UNDEFINED)
	{
		// on team but havent chosen a class, usually dead or just joining

		int chosenBotClass = CLASS_UNKNOWN;

		switch (RANDOM_LONG(1, 6))
		{
			case 1:
			{
				chosenBotClass = CLASS_SOLDIER;
				break;
			}
			case 2:
			{
				chosenBotClass = CLASS_ENGINEER;
				break;
			}
			case 3:
			{
				chosenBotClass = CLASS_SPY;
				break;
			}
			case 4:
			{
				chosenBotClass = CLASS_DEMOMAN;
				break;
			}
			case 5:
			{
				chosenBotClass = CLASS_HEAVY;
				break;
			}
			case 6:
			{
				chosenBotClass = CLASS_SOLDIER;
				break;
			}
		}

		// this forces a spawn on the bot's class, and is specific for bots due to them not being networked n shit
		// probably a better way to do this but as of right now its fine
		pBot->m_iClass = pBot->m_iNewClass = chosenBotClass;
		pBot->Spawn();
		Bot_Start(client);
	}
	
	g_BotData[client].altTabbedTimer -= frametime;
	if (g_BotData[client].altTabbedTimer < 0.0)
		g_BotData[client].altTabbedTimer = 0.0;
	g_BotData[client].noMouseTimer -= frametime;
	if (g_BotData[client].noMouseTimer < 0.0)
		g_BotData[client].noMouseTimer = 0.0;

	g_BotData[client].combatPercent -= 1.0;
	if (g_BotData[client].combatPercent < 0.0)
		g_BotData[client].combatPercent = 0.0;
	if (g_BotData[client].combatPercent > 100.0)
		g_BotData[client].combatPercent = 100.0;

	if (g_BotData[client].Ego < 0)
		g_BotData[client].Ego = 0;

	if (g_BotData[client].altTabbedTimer > 0.0)
	{
		pBot->pev->button = 0;
		return;
	}

	g_BotData[client].Paranoia -= 1;

	if (g_BotData[client].Paranoia < 10)
		g_BotData[client].Paranoia = 10;
	if (g_BotData[client].Paranoia > 100)
		g_BotData[client].Paranoia = 100;

	if (pBot->IsAlive())
	{
		Bot_AliveThink(client, &vecViewAngles, &vecMove);
	}
	else
	{
		Bot_DeadThink(client, &vecViewAngles, &vecMove);
	}
	
	g_engfuncs.pfnRunPlayerMove(pBot->edict(), vecViewAngles, vecMove[0], vecMove[1], vecMove[2], pBot->pev->button, pBot->pev->impulse, msec);

	g_LastBotUpdateTime[client] = gpGlobals->time;
}

//-----------------------------------------------------------------------------
// Purpose: Run through all the Bots in the game and let them think.
//-----------------------------------------------------------------------------
void Bot_RunAll(void)
{
	for (int i = 1; i <= gpGlobals->maxClients; i++)
	{
		if (isTempBot(i))
		{
			Bot_Think(i);
		}
	}
}


void Bot_Start(int client)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));
	int customDifficulty = CVAR_GET_FLOAT("tf_bot_difficulty");

	if (customDifficulty == -1)
	{
		// averages the difficulties of the bots on the servers in order to keep the average player around the same skill
		int averageDiff = 0;
		int amount = 0;
		for (int i = 1; i <= gpGlobals->maxClients; i++)
		{
			if (!isTempBot(i) || i == client)
				continue;
			averageDiff += g_BotData[client].Difficulty[0];
			amount += 1;
		}
		averageDiff /= (amount > 0 ? amount : 1);
		// raw average difficulty of all bots in the server

		averageDiff = (5 + averageDiff) / 2;
		// puts it against 5 so its closer to the middle difficulty
		// ex. averageDiff is 10 -> this averages it against 5 -> averageDiff is 7
		// ex. averageDiff is 0 -> this averages it against 5 -> averageDiff is 2
		// ex. averageDiff is 2 -> this averages it against 5 -> averageDiff is 3

		g_BotData[client].Difficulty[0] = RANDOM_LONG(averageDiff - 1, averageDiff + 1);
	}
	else if (customDifficulty > 0)
	{
		g_BotData[client].Difficulty[0] = customDifficulty;
	}

	if (g_BotData[client].Difficulty[0] < 0)
		g_BotData[client].Difficulty[0] = 0;

	bool setClassMainDiff = false;

	for (int i = 1; i < 10; i++)
	{
		g_BotData[client].Difficulty[i] = g_BotData[client].Difficulty[0];
		// fallback bcuz sometimes the setClassMainDiff causes a class difficulty to be skipped

		g_BotData[client].Difficulty[i] += RANDOM_LONG(-1, 1);
		// random small increase for variety

		if ((RANDOM_LONG(0, 9) == 0 || i == 9) && !setClassMainDiff)
		{
			// sets the class that the bot is the best at
			// the increase is based off the base difficulty
			// noobs are usually not as good at other classes, so their main is still bad ( diff 1 bot is diff 2 on their main class )
			// average players usually grind their main, so their main can be noticably better ( diff 5 bot is diff 10 on their main class )
			// good players also do this, but since they are already good, it usually leads to diminishing returns due to them already being good, so not that big of a difference ( diff 10 sniper is already cracked, so they are also cracked at the game in general, so they will be diff 10 everywhere else )

			g_BotData[client].Difficulty[i] = g_BotData[client].Difficulty[0] + RANDOM_LONG(0, g_BotData[client].Difficulty[0]);
			setClassMainDiff = true;
		}

		if (g_BotData[client].Difficulty[i] > 10)
			g_BotData[client].Difficulty[i] = 10;
		if (g_BotData[client].Difficulty[i] < 0)
			g_BotData[client].Difficulty[i] = 0;
		// clamps difficulty
		// normally it wouldnt cause any issues to have bots higher than 10 diff
		// However, a lot of the math can cause certain diff-based to either be equivalent to diff 9 OR just not work
		// same with diffs below 0
	}
	// difficulty setting

	g_BotData[client].BaseReactionTime = RANDOM_FLOAT(0.175, 0.25);
	g_BotData[client].BaseReactionTime += ((RANDOM_LONG(0, 1) == 0) ? 0.0152 : 0.0303);
	// reaction time setting + stimulating lag

	for (int i = 0; i < 6; i++)
	{
		g_BotData[client].personalLevel[i] = LEVEL_NONE;
	}	
	g_BotData[client].personalLevel[0] = LEVEL_4;
	g_BotData[client].personalLevel[1] = LEVEL_3_4;
	g_BotData[client].personalLevel[2] = LEVEL_2;
	if (pBot->m_iClass == CLASS_SPY)
		g_BotData[client].personalLevel[2] = LEVEL_3_4;
	// movement level setting
	// this is kinda subjective
	// as of right now, i do not know how to access the fire rate of the individual weapon
	// due to this, i just kinda use stereotypical levels based on the weapon
	// sorry....

	g_BotData[client].combatPercent = 50.0;
	g_BotData[client].altTabbedTimer = 0.0;
	g_BotData[client].noMouseTimer = 0.0;
	g_BotData[client].pyroSpycheckTimer = 0;
	g_BotData[client].spyBackstabTimer = 0;
	g_BotData[client].LastTimeReacted = gpGlobals->time;
	g_BotData[client].Ego = RANDOM_LONG(0, 50);
	g_BotData[client].Paranoia = RANDOM_LONG(10, g_BotData[client].Difficulty[0] * 9);
	g_BotData[client].MechanicalSkill = RANDOM_LONG(g_BotData[client].Difficulty[0] * 9, 100);
}


//-----------------------------------------------------------------------------
// Purpose: Handle the Bot AI for a live bot
//-----------------------------------------------------------------------------
void Bot_AliveThink(int client, Vector* vecAngles, Vector* vecMove)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (g_BotData[client].RecentDamageTaken[1] + 2.0 < GetGameTime())
		g_BotData[client].RecentDamageTaken[0] = 0.0;

	g_BotData[client].Targets[0] = FindNearestEnemy(client, 0, 2048);
	// this can be extended but 2048 is fine for now

	// if (!IsTargetVisible(client, g_BotData[client].Targets[0]))
		g_BotData[client].Targets[0] = NULL;
	// this is probably not needed but sometimes the bot breaks without it

	if (g_BotData[client].Targets[0] != NULL)
	{
		g_BotData[client].combatPercent += (2 * g_BotData[client].Difficulty[0]) + 5;
		if (g_BotData[client].combatPercent > 100.0)
			g_BotData[client].combatPercent = 100.0;
		// ALERT(at_console, "Botthink: updated and tried to aim at valid target!\n");
		
		TF2_LookAtPos(client, vecAngles, g_BotData[client].Targets[0]->pev->origin, 0.05);

		CBasePlayerWeapon* pWeapon = (CBasePlayerWeapon*)pBot->m_pActiveItem;

		if (pWeapon)
		{
			int clipSize = pWeapon->m_iClip;
			if (clipSize != -1)
			{
				if (clipSize > 0)
				{
					///ALERT(at_console, "Botthink: I have ammo / COULD have ammo, fire!\n");
					pBot->pev->button |= IN_ATTACK;
				}
				else
				{
					///ALERT(at_console, "Botthink: I have ammo but need to reload!\n");
					pBot->pev->button |= IN_RELOAD;
				}
			}
			else
			{
				///ALERT(at_console, "Botthink: No Ammo on this weapon!\n");
				pBot->pev->button |= IN_ATTACK;

				// try attacking anyway; melee weapons usually have no ammo
			}
		}
	}

	Bot_AliveMovementThink(client, vecAngles, vecMove);
	Bot_AliveWeaponThink(client, vecAngles, vecMove);
}

void Bot_AliveMovementThink(int client, Vector* vecAngles, Vector* vecMove)
{
	vecMove->z = 0.0;

	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (pBot->m_flSpawnTime + 5 > gpGlobals->time)
	{
		vecMove->x = 500.0;

		if (client % 2 == 0)
			vecMove->y = 500.0;
		else
			vecMove->y = -500.0;
	}

	// movement based
	// gotta learn how to make the bot walk normally first
	// after i figure out the basics then i will start getting serious with it
	// im used to writing bots in normal TF2, so I will port that logic over
	
	if (pBot->pev->waterlevel >= 3)
	{
		g_BotData[client].timeSpentUnderwater += ((gpGlobals->time - g_LastBotUpdateTime[client]) <= 0) ? (gpGlobals->time - g_LastBotUpdateTime[client]) : 0;

		// if in deep water or not fighting, bot will try to surface for air
		// if there is an enemy, the bot will be willing to go underwater for a bit
		// however, after 10 updates then the bot will go upwards

		if (g_BotData[client].timeSpentUnderwater > 10.0 || (g_BotData[client].Targets[0] == NULL) )
			pBot->pev->button |= IN_JUMP;
	}
	else
		g_BotData[client].timeSpentUnderwater -= ((gpGlobals->time - g_LastBotUpdateTime[client]) <= 0) ? (gpGlobals->time - g_LastBotUpdateTime[client]) : 0;

	if (g_BotData[client].timeSpentUnderwater < 0.0)
		g_BotData[client].timeSpentUnderwater = 0.0;

	if (g_BotData[client].Targets[0] != NULL)
	{
		int random = g_engfuncs.pfnRandomLong(0, 100);
		if (random == 1 || pBot->pev->waterlevel >= 3)
		{
			// randomly while fighting, bot will try to jump
			pBot->pev->button |= IN_JUMP;
		}
		else if (random == 2)
		{
			pBot->pev->button |= IN_DUCK;
		}

		if (pBot->m_pActiveItem)
		{
			if (pBot->m_pActiveItem->m_iId == WEAPON_CROWBAR ||
				pBot->m_pActiveItem->m_iId == WEAPON_BAT ||
				pBot->m_pActiveItem->m_iId == WEAPON_SHOVEL ||
				pBot->m_pActiveItem->m_iId == WEAPON_FIREAXE ||
				pBot->m_pActiveItem->m_iId == WEAPON_BOTTLE ||
				pBot->m_pActiveItem->m_iId == WEAPON_FISTS ||
				pBot->m_pActiveItem->m_iId == WEAPON_BONESAW ||
				pBot->m_pActiveItem->m_iId == WEAPON_KUKRI ||
				pBot->m_pActiveItem->m_iId == WEAPON_WRENCH ||
				pBot->m_pActiveItem->m_iId == WEAPON_KNIFE)
			{
				vecMove->x = 500.0; // if holding melee, go forward into enemy

				if (pBot->pev->velocity.Length2D() > 300.0 && random == 3)
				{
					// randomly jump
					pBot->pev->button |= IN_JUMP;
				}
			}
			else
			{
				if (random % 6 == 0)
					vecMove->y = 500.0;
				else if (random % 6 == 1)
					vecMove->y = -500.0;
				else
					vecMove->x = 500.0;

				if (pBot->m_pActiveItem->m_iId == WEAPON_RPG || 
					pBot->m_pActiveItem->m_iId == WEAPON_GRENADELAUNCHER)
				{
					if ( random % 3 == 0 && (pBot->pev->button & IN_ATTACK) && (pBot->m_pActiveItem->GetWeaponPtr()->m_flNextPrimaryAttack - gpGlobals->time <= 0.0) )
					{
						pBot->pev->button |= IN_JUMP;
					}
				}
			}
		}
	}
}

void Bot_AliveWeaponThink(int client, Vector* vecAngles, Vector* vecMove)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (g_BotData[client].Targets[0] != NULL) // in commbat
	{
		switch (pBot->m_iClass)
		{
			case CLASS_SCOUT:
			{
				if (pBot->m_pActiveItem->GetWeaponPtr()->m_iClip <= 0 && !(pBot->m_pActiveItem->m_iId == WEAPON_BAT))
				{
					if (pBot->m_pActiveItem->m_iId == WEAPON_SCATTERGUN)
					{
						pBot->SelectItem("weapon_pistol");
					}
					else
						pBot->SelectItem("weapon_bat");
					
				}

				break;
			}
			case CLASS_SNIPER:
			{
				if (pBot->m_pActiveItem->m_iId == WEAPON_SNIPERRIFLE)
				{
					if ((pBot->m_pActiveItem->GetWeaponPtr()->m_flNextPrimaryAttack - gpGlobals->time <= 0.0) && !pBot->IsInCond(TF_COND_AIMING))
					{
						pBot->pev->button |= IN_ATTACK2;
					}
				}
				break;
			}
			case CLASS_SOLDIER:
			{
				float distancefrom = (g_BotData[client].Targets[0]->pev->origin - pBot->pev->origin).Length();

				if (distancefrom <= 75.0)
				{
					pBot->SelectItem("weapon_shovel");
				}
				else if (distancefrom <= 275.0)
				{
					pBot->SelectItem("weapon_shotgun");
				}
				else
				{
					pBot->SelectItem("weapon_rpg");
				}
				break;
			}
			default: break;
		}
	}
}

//-----------------------------------------------------------------------------
// Purpose: Handle the Bot AI for a dead bot
//-----------------------------------------------------------------------------
void Bot_DeadThink(int client, Vector* vecAngles, Vector* vecMove)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));
	// Wait for Reinforcement wave
	if (!pBot->IsAlive())
	{
		// Wait for a few seconds before respawning.
		//if (gpGlobals->time - pBot->m_flSpawnTime > 3)
		//{
			// Respawn the bot
		//	pBot->pev->button |= IN_JUMP;
		//}
	}
}

CBaseEntity* FindNearestEnemy(int client, int mode, float MAXRANGE = 4096.0)
{
	// mode 0 = enemies
	// mode 1 = teammates
	// anything else = all

	auto player = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (!player)
	{
		return NULL;
	}

	CBaseEntity* pEntity = NULL;
	CBaseEntity* pNearest = NULL;
	float flMinDist = MAXRANGE;
	
	// Search for enemies
	for (int edict = 1; edict <= gpGlobals->maxClients; edict++)
	{
		pEntity = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(edict));

		if (pEntity == NULL)
			continue;
		if (!pEntity)
			continue;
		// DOUBLE CHECK BCUZ THIS ENGINE IS STUPID

		if (!pEntity->pev)
			continue;
		
		// Skip non-living entities
		if (!pEntity->IsAlive())
		{
			g_BotData[client].AwarenessOfClient[edict] = 0.0;
			continue;
			// this makes sure that any awareness get reset for dead or invalid edicts
		}

		// Skip self
		if (pEntity == player)
			continue;

		CBasePlayer* edictPlayer = GetClassPtr((CBasePlayer*)(pEntity->pev));

		if (edictPlayer->m_iTeam == player->m_iTeam)
			continue;

		// Check if it's a valid player
		if (!pEntity->IsPlayer())
			continue;

		if (g_BotData[client].AwarenessOfClient[edict] < 0.0)
			g_BotData[client].AwarenessOfClient[edict] = 0.0;
		if (g_BotData[client].AwarenessOfClient[edict] > 100.0)
			g_BotData[client].AwarenessOfClient[edict] = 100.0;

		if (!IsTargetVisible(client, pEntity))
		{
			g_BotData[client].AwarenessOfClient[edict] -= ((0 - (0.4 * g_BotData[client].Difficulty[0])) + 5);

			if (g_BotData[client].DisregardTimer[edict] == -2.0)
				g_BotData[client].DisregardTimer[edict] = RANDOM_FLOAT(100, 200);

			continue;
		}

		if (angleCoordsToFaceCoords(player->pev->v_angle, player->pev->origin, edictPlayer->pev->origin, true) <= 70.0)
		{
			g_BotData[client].AwarenessOfClient[edict] += 10 * g_BotData[client].Difficulty[0];
		}
		else
		{
			g_BotData[client].AwarenessOfClient[edict] -= ((0 - (0.4 * g_BotData[client].Difficulty[0])) + 5);
		}

		if (g_BotData[client].DisregardTimer[edict] > 0.0)
			g_BotData[client].DisregardTimer[edict] -= 1.0;

		if (g_BotData[client].DisregardTimer[edict] > 0.0 || g_BotData[client].DisregardTimer[edict] == -1.0 || g_BotData[client].DisregardTimer[edict] == -2.0 || g_BotData[client].DisregardTimer[edict] == -3.0 || g_BotData[client].DisregardTimer[edict] == -4.0)
			continue;
		// if the bot was ignoring them, then disregard
		// ignore the several or thingys here
		// the normal way didnt want to work sometimes

		if (g_BotData[client].AwarenessOfClient[edict] < (((0 - 0.8) * g_BotData[client].combatPercent) + 90))
			continue;
		// if the bot still isnt aware, then the target is ignored

		float flDist = (pEntity->pev->origin - player->pev->origin).Length();

		if (flDist > MAXRANGE)
		{
			continue;
		}

		if (flDist < flMinDist)
		{
			flMinDist = flDist;
			pNearest = pEntity;
		}
	}

	return pNearest;
}

float clamp(float init, float min, float max)
{
	float main = init;
	if (main > max)
		main = max;
	if (main < min)
		main = min;

	return main;
}


float AngleNormalize(float angle)
{
	angle = fmodf(angle, 360.0);
	if (angle > 180)
	{
		angle -= 360;
	}
	if (angle < -180)
	{
		angle += 360;
	}

	return angle;
}

bool IsTargetVisible(int client, CBaseEntity* pTarget)
{
	auto player = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (!player)
		return false;

	if (!pTarget)
		return false;

	// Skip non-living entities
	if (!pTarget->IsAlive() || !player->IsAlive())
		return false;

	// Check line of sight
	TraceResult tr;
	UTIL_TraceLine(player->GetGunPosition(), pTarget->pev->origin + pTarget->pev->view_ofs,
		ignore_monsters, ignore_glass, ENT(pTarget->pev), &tr);

	return (tr.flFraction >= 1.0f || tr.pHit == pTarget->edict());
}

void BotFixIdealPitch(edict_t* pEdict)
{
	// check for wrap around of angle...
	if (pEdict->v.idealpitch > 180)
		pEdict->v.idealpitch -= 360;
	else if (pEdict->v.idealpitch < -180)
		pEdict->v.idealpitch += 360;
}

void BotFixIdealYaw(edict_t* pEdict)
{
	// check for wrap around of angle...
	if (pEdict->v.ideal_yaw > 180)
		pEdict->v.ideal_yaw -= 360;
	else if (pEdict->v.ideal_yaw < -180)
		pEdict->v.ideal_yaw += 360;
}

// This function will tell the bot to face the map coordinates
// indicated by v_focus
void BotMatchFacing(CBasePlayer* pBot, const Vector& v_source, Vector v_focus)
{
	v_focus = v_focus - (pBot->pev->origin + pBot->pev->view_ofs);
	const Vector bot_angles = UTIL_VecToAngles(v_focus);
	pBot->pev->ideal_yaw = bot_angles.y;
	pBot->pev->idealpitch = bot_angles.x;
	BotFixIdealYaw(pBot->edict());
	BotFixIdealPitch(pBot->edict());
	pBot->ChangeYaw(pBot->pev->yaw_speed);
}