/***
*
*	Copyright (c) 1996-2001, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
/*

===== tf_bot.cpp ========================================================

  bot stuff :O
  this is a simple bot that only looks, walks towards enemies, and shoots. Not much else

*/

#include <algorithm>
#include <string>
#include <vector>

#include "extdll.h"
#include "util.h"
#include "filesystem_utils.h"
#include "cbase.h"
#include "com_model.h"
#include "saverestore.h"
#include "player.h"
#include "spectator.h"
#include "client.h"
#include "soundent.h"
#include "gamerules.h"
#include "game.h"
#include "customentity.h"
#include "weapons.h"
#include "weaponinfo.h"
#include "usercmd.h"
#include "netadr.h"
#include "pm_shared.h"
#include "pm_defs.h"
#include "UserMessages.h"
#include "tf_bot.h"
#include "teamplay_gamerules.h"

// CODE GRABBED FROM THE TF2SDK

static float g_LastBotUpdateTime[34];
static CBaseEntity* enemy[40];

inline bool isTempBot(int client)
{
	auto pPlayer = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	return (pPlayer && pPlayer->m_bIsConnected && (pPlayer->pev->flags & FL_FAKECLIENT) != 0);
}

//-----------------------------------------------------------------------------
// Purpose: Run this Bot's AI for one frame.
//-----------------------------------------------------------------------------
void Bot_Think(int client)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	// Make sure we stay being a bot
	if ((pBot->pev->flags & FL_FAKECLIENT) != 0)
		pBot->pev->flags |= FL_FAKECLIENT;

	float frametime = gpGlobals->time - g_LastBotUpdateTime[client];
	g_LastBotUpdateTime[client] = gpGlobals->time;

	if (frametime > 0.25f || frametime < 0)
	{
		frametime = 0;
	}
	
	const byte msec = byte(frametime * 1000.0);

	// pBot->pev->view_ofs;
	Vector vecMove(0, 0, 0);
	byte impulse = 0;
	Vector vecViewAngles = pBot->pev->angles;
	pBot->pev->button = 0;

	// Create some random values
	if (pBot->GetTeamNumber() == TEAM_UNASSIGNED)
	{
		pBot->SetTeamNumber((RANDOM_LONG(0, 1) ? TEAM_RED : TEAM_BLUE));
	}
	else if (pBot->GetTeamNumber() != TEAM_UNASSIGNED && pBot->m_iClass == CLASS_UNDEFINED)
	{
		// on team but havent chosen a class, usually dead or just joining

		int chosenBotClass = RANDOM_LONG(1, 9); //((RANDOM_LONG(0, 1) ? CLASS_SOLDIER : CLASS_SCOUT));

		// specific for bots due to them not being networked n shit
		// probably a better way to do this but as of right now its fine
		pBot->m_iClass = pBot->m_iNewClass = chosenBotClass;
		pBot->Spawn();
	}
	
	if (pBot->IsAlive())
	{
		Bot_AliveThink(client, &vecViewAngles, &vecMove);
	}
	else
	{
		Bot_DeadThink(client, &vecViewAngles, &vecMove);
	}
	
	g_engfuncs.pfnRunPlayerMove(pBot->edict(), vecViewAngles, vecMove[0], vecMove[1], vecMove[2], pBot->pev->button, pBot->pev->impulse, msec);
}

//-----------------------------------------------------------------------------
// Purpose: Run through all the Bots in the game and let them think.
//-----------------------------------------------------------------------------
void Bot_RunAll(void)
{
	for (int i = 1; i <= gpGlobals->maxClients; i++)
	{
		if (isTempBot(i))
		{
			Bot_Think(i);
		}
	}
}

//-----------------------------------------------------------------------------
// Purpose: Handle the Bot AI for a live bot
//-----------------------------------------------------------------------------
void Bot_AliveThink(int client, Vector* vecAngles, Vector* vecMove)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));
	// trace_t trace;
	
	// m_bWasDead = false;

	// In item testing mode, we run custom logic
	// from tf2sdk, not implemented YET
	//if (TFGameRules()->IsInItemTestingMode())
	//{
	//	Bot_ItemTestingThink(vecAngles, vecMove);
	//	return;
	//}

	enemy[client] = FindNearestEnemy(client, 4096); // this can be extended but 4096 is fine for now
	
	if (!IsTargetVisible(client, enemy[client])) // this works FINE. DO NOT TOUCH
		enemy[client] = NULL;

	if (enemy[client] != NULL)
	{
		// ALERT(at_console, "Botthink: updated and tried to aim at valid target!\n");
		AimAtTarget(client, enemy[client]);
		// BotMatchFacing(pBot, pBot->pev->origin, enemy[client]->edict()->v.origin);
		
		// TF2_LookAtPos(client, vecAngles, enemy[client]->pev->origin, 0.5);
		// g_engfuncs.pfnWalkMove(pBot->edict(), pBot->pev->v_angle.y, 1.0, WALKMOVE_NORMAL);
		
		CBasePlayerWeapon* pWeapon = (CBasePlayerWeapon*)pBot->m_pActiveItem;

		if (pWeapon)
		{
			int clipSize = pWeapon->m_iClip;
			if (clipSize != -1)
			{
				if (clipSize > 0)
				{
					///ALERT(at_console, "Botthink: I have ammo / COULD have ammo, fire!\n");
					pBot->pev->button |= IN_ATTACK;
				}
				else
				{
					///ALERT(at_console, "Botthink: I have ammo but need to reload!\n");
					pBot->pev->button |= IN_RELOAD;
				}
			}
			else
			{
				///ALERT(at_console, "Botthink: No Ammo on this weapon!\n");
				pBot->pev->button |= IN_ATTACK;

				// try attacking anyway; melee weapons usually have no ammo
			}
		}
	}
	else
	{
		// ALERT(at_console, "Botthink: Couldn't get player!\n");
	}

	Bot_AliveMovementThink(client, vecAngles, vecMove);
	Bot_AliveWeaponThink(client, vecAngles, vecMove);

	// Miscellaneous
	//if (bot_saveme.GetInt() > 0)
	//{
		//m_hBot->SaveMe();
		//bot_saveme.SetValue(bot_saveme.GetInt() - 1);
	//}
}

void Bot_AliveMovementThink(int client, Vector* vecAngles, Vector* vecMove)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));
	// pBot->pev->button |= IN_FORWARD;

	if (pBot->m_fDeadTime + 10 > gpGlobals->time)
	{
		if (RANDOM_LONG(0, 1) == 1)
			vecMove->y = 500.0;
		else
			vecMove->x = 500.0;
	}
	vecMove->z = 0.0;

	// movement based
	// gotta learn how to make the bot walk normally first
	// after i figure out the basics then i will start getting serious with it
	// im used to writing bots in normal TF2, so I will port that logic over
	// 
	if( (enemy[client] != NULL && g_engfuncs.pfnRandomLong(0, 100) == 1)
		|| pBot->pev->waterlevel >= 3)
	{
		// if in deep water or randomly while fighting, bot will try to 
		pBot->pev->button |= IN_JUMP;
	}

	if (enemy[client] != NULL && g_engfuncs.pfnRandomLong(0, 100) == 2)
	{
		pBot->pev->button |= IN_DUCK;
	}
	// TODO: port the bot_jump & bot_duck commands from tf2
}

void Bot_AliveWeaponThink(int client, Vector* vecAngles, Vector* vecMove)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));
	//
}

//-----------------------------------------------------------------------------
// Purpose: Handle the Bot AI for a dead bot
//-----------------------------------------------------------------------------
void Bot_DeadThink(int client, Vector* vecAngles, Vector* vecMove)
{
	auto pBot = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));
	// Wait for Reinforcement wave
	if (!pBot->IsAlive())
	{
		/*
		if (m_bWasDead)
		{
			// Wait for a few seconds before respawning.
			if (gpGlobals->curtime - m_flDeadTime > 3)
			{
				// Respawn the bot
				buttons |= IN_JUMP;
			}
		}
		else
		{
			// Start a timer to respawn them in a few seconds.
			m_bWasDead = true;
			m_flDeadTime = gpGlobals->curtime;
		}
		*/
	}
}

CBaseEntity* FindNearestEnemy(int client, float MAXRANGE = 4096.0)
{
	auto player = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (!player)
	{
		return NULL;
	}

	CBaseEntity* pEntity = NULL;
	CBaseEntity* pNearest = NULL;
	float flMinDist = MAXRANGE;
	
	// Search for enemies
	while ((pEntity = UTIL_FindEntityInSphere(pEntity, player->pev->origin, 2048)) != NULL)
	{
		if (!pEntity->pev)
			continue;

		// Skip non-living entities
		if (!pEntity->IsAlive())
			continue;
		
		// Skip teammates (basic team check)
		// if (pEntity->pev->team == player->pev->team)
			// continue;
		// broken

		// Skip self
		if (pEntity == player)
			continue;

		CBasePlayer* edictPlayer = GetClassPtr((CBasePlayer*)(pEntity->pev));
		//entvars_t* pev = &pEntity->v;

		//CBasePlayer* pl = (CBasePlayer*)CBasePlayer::Instance(pev);

		if (edictPlayer->m_iTeam == player->m_iTeam)
			continue;

		// Check if it's a valid player
		if (!pEntity->IsPlayer())
			continue;

		if (!IsTargetVisible(client, pEntity))
			continue;

		float flDist = (pEntity->pev->origin - player->pev->origin).Length();

		if (flDist < flMinDist)
		{
			flMinDist = flDist;
			pNearest = pEntity;
		}
	}

	return pNearest;
}

// converted from TF2Ebots
//
void TF2_LookAtPos(int client, Vector* vecAngles, float flGoal[3], float flAimSpeed)
{
	auto player = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (!player)
	{
		return;
	}


	Vector flPos = player->pev->view_ofs;
	Vector flAng = player->pev->angles;

	// get normalised direction from target to client
	Vector desired_dir;
	desired_dir[0] = flGoal[0] - flPos[0];
	desired_dir[1] = flGoal[1] - flPos[1];
	desired_dir[2] = flGoal[2] - flPos[2];

	desired_dir = UTIL_VecToAngles(desired_dir);

	// ease the current direction to the target direction
	flAng[0] += AngleNormalize(desired_dir[0] - flAng[0]) * flAimSpeed;
	flAng[1] += AngleNormalize(desired_dir[1] - flAng[1]) * flAimSpeed;

	// Set view angles
	player->pev->v_angle = flAng;
	//player->pev->angles.x = vecCurrentAngles.x / 3.0f; // Pitch for model
	player->pev->angles.y = flAng.y;
	player->pev->angles.z = 0;

	// Update ideal yaw for movement
	player->pev->ideal_yaw = flAng.y;

	// Set angle change for smooth turning
	player->ChangeYaw(player->pev->yaw_speed);

	// TeleportEntity(client, NULL_VECTOR, flAng, NULL_VECTOR);
}

void AimAtTarget(int client, CBaseEntity* pTarget)
{
	auto player = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (!player)
	{
		return;
	}

	if (!pTarget)
		return;

	// Calculate target position (aim at chest/head)
	Vector vecTarget = pTarget->pev->origin + Vector(0, 0, pTarget->pev->view_ofs.z * 0.8f);
	Vector vecDir = (vecTarget - player->GetGunPosition()).Normalize();

	// Convert direction to angles
	Vector vecTargetAngles = UTIL_VecToAngles(vecDir);

	// Smooth aiming - interpolate towards target
	Vector vecCurrentAngles = player->pev->v_angle;

	// Normalize angle differences
	float flYawDiff = UTIL_AngleMod(vecTargetAngles.y - vecCurrentAngles.y);
	float flPitchDiff = UTIL_AngleMod(vecTargetAngles.x - vecCurrentAngles.x);

	// Apply aim speed (lower = slower, more human-like)
	// float flAimDelta = 5.0;

	// vecCurrentAngles.y += clamp(flYawDiff, -flAimDelta, flAimDelta);
	// vecCurrentAngles.x += clamp(flPitchDiff, -flAimDelta, flAimDelta);

	vecCurrentAngles.y += flYawDiff;
	vecCurrentAngles.x += flPitchDiff;

	// Set view angles
	player->pev->v_angle = vecCurrentAngles;
	player->pev->angles.x = vecCurrentAngles.x; // Pitch for model
	player->pev->angles.y = vecCurrentAngles.y;
	player->pev->angles.z = 0;

	// Update ideal yaw for movement
	player->pev->ideal_yaw = vecCurrentAngles.y;

	BotFixIdealPitch(player->edict());
	BotFixIdealYaw(player->edict());
	// Set angle change for smooth turning
	player->ChangeYaw(1048);
}

float clamp(float init, float min, float max)
{
	// clamp(flYawDiff, -flAimDelta, flAimDelta);

	float main = init;
	if (main > max)
		main = max;
	if (main < min)
		main = min;

	return main;
}


float AngleNormalize(float angle)
{
	angle = fmodf(angle, 360.0);
	if (angle > 180)
	{
		angle -= 360;
	}
	if (angle < -180)
	{
		angle += 360;
	}

	return angle;
}

bool IsTargetVisible(int client, CBaseEntity* pTarget)
{
	auto player = static_cast<CBasePlayer*>(UTIL_PlayerByIndex(client));

	if (!player)
		return false;

	if (!pTarget)
		return false;

	// Skip non-living entities
	if (!pTarget->IsAlive() || !player->IsAlive())
		return false;

	// Check line of sight
	TraceResult tr;
	UTIL_TraceLine(player->GetGunPosition(), pTarget->pev->origin + pTarget->pev->view_ofs,
		ignore_monsters, ignore_glass, ENT(pTarget->pev), &tr);

	return (tr.flFraction >= 1.0f || tr.pHit == pTarget->edict());
}

void BotFixIdealPitch(edict_t* pEdict)
{
	// check for wrap around of angle...
	if (pEdict->v.idealpitch > 180)
		pEdict->v.idealpitch -= 360;
	else if (pEdict->v.idealpitch < -180)
		pEdict->v.idealpitch += 360;
}

void BotFixIdealYaw(edict_t* pEdict)
{
	// check for wrap around of angle...
	if (pEdict->v.ideal_yaw > 180)
		pEdict->v.ideal_yaw -= 360;
	else if (pEdict->v.ideal_yaw < -180)
		pEdict->v.ideal_yaw += 360;
}

// This function will tell the bot to face the map coordinates
// indicated by v_focus
void BotMatchFacing(CBasePlayer* pBot, const Vector& v_source, Vector v_focus)
{
	v_focus = v_focus - (pBot->pev->origin + pBot->pev->view_ofs);
	const Vector bot_angles = UTIL_VecToAngles(v_focus);
	pBot->pev->ideal_yaw = bot_angles.y;
	pBot->pev->idealpitch = bot_angles.x;
	BotFixIdealYaw(pBot->edict());
	BotFixIdealPitch(pBot->edict());
	pBot->ChangeYaw(pBot->pev->yaw_speed);
}